<?xml version="1.0" encoding="UTF-8"?><!-- generator="wordpress/2.3.3" -->
<rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	>
<channel>
	<title>Comments on: Continuous testing does not require static analysis</title>
	<link>http://adventuresinsoftware.com/blog/?p=438</link>
	<description>Lessons learned on the road to quality computing</description>
	<pubDate>Fri, 13 Jan 2017 12:56:57 +0000</pubDate>
	<generator>http://wordpress.org/?v=2.3.3</generator>
		<item>
		<title>By: Ben Rady</title>
		<link>http://adventuresinsoftware.com/blog/?p=438#comment-47825</link>
		<dc:creator>Ben Rady</dc:creator>
		<pubDate>Fri, 18 Sep 2009 02:51:48 +0000</pubDate>
		<guid>http://adventuresinsoftware.com/blog/?p=438#comment-47825</guid>
		<description>Mike,

So there's two problems we've found with using code coverage data for test selection in a continuous test runner. I covered some of this in the talk I gave at Agile2008 on continuous testing (http://submissions.agile2008.org/node/377).

One, if you're using code coverage to determine which tests to run, you need to run all the tests to get it (which kind of defeats the purpose of test selection). Static analysis allows you to pick which tests to run before actually running them. Sure, you can track the state of the line level dependencies and try to maintain it as classes change, but....

the other problem with this approach is the huge volume of data you generate. Because it's so simple, Infinitest is able to keep it's dependency graph in memory. That means it runs quickly and easily scales to workspaces with tens of thousands of classes. If we kept line level dependency information for each test, we'd have to store it on disk. That might be OK for a build tool or something like that, but for a CT runner, that kind of file IO would kill the responsiveness of the tool.

Thanks for the feedback.

Ben</description>
		<content:encoded><![CDATA[<p>Mike,</p>
<p>So there's two problems we've found with using code coverage data for test selection in a continuous test runner. I covered some of this in the talk I gave at Agile2008 on continuous testing (http://submissions.agile2008.org/node/377).</p>
<p>One, if you're using code coverage to determine which tests to run, you need to run all the tests to get it (which kind of defeats the purpose of test selection). Static analysis allows you to pick which tests to run before actually running them. Sure, you can track the state of the line level dependencies and try to maintain it as classes change, but....</p>
<p>the other problem with this approach is the huge volume of data you generate. Because it's so simple, Infinitest is able to keep it's dependency graph in memory. That means it runs quickly and easily scales to workspaces with tens of thousands of classes. If we kept line level dependency information for each test, we'd have to store it on disk. That might be OK for a build tool or something like that, but for a CT runner, that kind of file IO would kill the responsiveness of the tool.</p>
<p>Thanks for the feedback.</p>
<p>Ben</p>
]]></content:encoded>
	</item>
</channel>
</rss>
